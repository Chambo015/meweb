<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MeWeb</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/prism.css">
    <script src="js/prism.js" defer></script>
    <link rel="stylesheet" href="css/main.css">
<!--     <script src="js/main.js" defer></script> -->
    <link rel="stylesheet" href="css/hardjs.css">
    <script src="js/hardjs.js" defr></script>
    <link rel="shortcut icon" href="img/logo.svg" type="image/x-icon">
</head>

<body>
    <header>
        <div class="container">
            <div class="top-wrapper">
                <a href="index.html" class="logo">
                    <img src="img/logo.svg" alt="logo">
                    <h1>ME<span>WEB</span></h1>
                </a>
                <nav>
                    <ul>
                        <li><a href="index.html">Главная</a></li>
                        <li><a href="#">Задачи</a></li>
                        <li><a href="#">В работе</a></li>
                    </ul>
                </nav>
            </div>
        </div>
    </header>
    <section class="home">
        <div class="container">
            <div class="hard-js">
                <h1 class="open-scheduling">Планирование: setTimeout и setInterval</h1>
                <div class="child scheduling hide">
                    <p class="content-text">Мы можем вызвать функцию не в данный момент, а позже, через заданный
                        интервал времени. Это называется «планирование
                        вызова».</p>

                    <p class="content-text"><b>setTimeout</b> позволяет вызвать функцию <b>один раз</b> через
                        определённый интервал времени.</p>

                    <pre><code class="language-js">function sayHi() {
    alert('Привет');
}
                  
setTimeout(sayHi, 1000); // данный код вызывает sayHi() спустя одну секунду:</code></pre>

                    <p class="content-text"><b>setInterval</b> позволяет вызывать функцию <b>регулярно</b>, повторяя
                        вызов через определённый интервал времени</p>
                    <pre><code class="language-js">setInterval(sayHi, 2000); // повторить с интервалом 2 секунды</code></pre>

                    <h2>Отмена через clearTimeout и clearInterval</h2>
                    <p class="content-text">Вызов <b>setTimeout</b> возвращает «идентификатор таймера» timerId, который можно использовать для отмены дальнейшего выполнения.</p>
                    <pre><code class="language-js">let timerId = setTimeout(() => {/* какой то код */}, 1000);
let intervalId = setInterval(() => {/* какой то код */}, 1000);

clearInterval(intervalId)
clearTimeout(timerId) </code></pre>
                    <h2>Рекурсивный вызов setTimeout</h2>
                    <p class="content-text">Например мы хоти вызывать Функцию каждые 500мс и мы можем использовать <b>setInterval()</b>, но реальная задержка между вызовами func с помощью setInterval меньше, чем указано. И это нормально ведь setInterval не ждет когда закончится выполнение function.</p> <p class="content-text">И если для выполнение function потребуется больше 500мс , в данном случае движок ждёт окончания выполнения function и затем проверяет планировщик и, если время истекло, немедленно запускает его снова, следовательно  вызовы будут выполняться без задержек вообще. </p>
                    <h3>Рекурсивный setTimeout гарантирует фиксированную задержку:</h3>
                    <pre><code class="language-js"> let id = setTimeout(function runBigCode() {
    /* Тут выполняется какой то код */;
    // следующий отсчет 500мс пойдет только после выполнения выше написанных кодов
    id = setTimeout(runBigCode, 500)
}, 500);</code></pre>

                    <h2>Анимация с помощью setTimeout</h2>
                    <p class="content-text"> Создадим функцию которая будет перемешать Синий квадрат в нижний правый угол. А именно будем добавлять css свойства: top и left.
                       
                    </p>
                    <pre class="language-js"><code>let pos = 0; // Начальные координаты top и left
let id = setInterval(frame, 10); // функция frame, которая увеличивает top и left на один px, вызывается каждые 10мс

function frame() {
    if (pos === 300) { // Если top и left равны 300, то мы отменяем Interval
        clearInterval(id)
    } else {
        pos++; // 
        box.style.top = pos + "px";
        box.style.left = pos + "px";
    }
}</code></pre>
                    <button class="btn">Animation</button>
                    <div class="box-wrapper">
                        <div class="box"></div>
                    </div>
                    

                </div>
                <!-- /.scheduling -->
                <h1 class="open-date">Дата и время new Date()</h1>
                <div class="child date hide">
                    <p class="conent-text"> <strong>new Date()</strong> возвращает текущую дату, если параметры не указаны</p>
                    <pre><code class="language-js">let now = new Date();
console.log(now) // Mon Jul 26 2021 14:40:44 GMT+0600 (Восточный Казахстан) </code></pre>
<p class="conent-text">Задать определенную дату можно в параметрах. Например <b>new Date("2012-01-26")</b> или <b>new Date(2012, 0, 26)</b> и если мы не укажем часы то по умолчанию будет полночь по Гринвичу. </p>
<p class="content-text"><b>Обратите внимание:</b> если функция Date вызывается в качестве конструктора с более, чем одним аргументом, значения, большие
логического диапазона (например, 13 в качестве номера месяца или 70 для значения минут) «переметнутся» на соседние
значения. Например, вызов <b>Date(2013, 13, 1)</b>  эквивалентен вызову <b>new Date(2014, 1, 1)</b>,</p>
<pre><code class="language-js">let date = new Date("2012-01-26");
console.log(date) //Thu Jan 26 2012 06:00:00 GMT+0600 (Восточный Казахстан)
// Так как я живу в Нур-Султане у меня время по умолчанию будет 06 часов утра
</code></pre>
<p class="conent-text">У объекта new Date() есть много методов, в основном эти методы <b>set</b> и <b>get</b>, соответственно одни помогают установить время, а другие получить</p>
<ul>
    <li><h3>Получение компонентов даты</h3>
    <pre><code class="language-js">let now = new Date();
// get методы возвращают number
now.getFullYear() // Получить год(4 цифры)
now.getMonth() // Получить месяц, от 0 до 11.
now.getDate() // Получить день месяца, от 1 до 31, что несколько противоречит названию метода.
now.getHours() // Получить, соответственно, часы 0 - 23 
now.getUTCHours() // Получить лондонское время
now.getMinutes() // Получить минуты
now.getSeconds() // Получить секунды
now.getMilliseconds() // Получить, соответственно,  миллисекунды.
now.getDay() // Вернуть день недели от 0(воскресенье) до 6(суббота).

getTime() Для заданной даты возвращает таймстамп – количество миллисекунд, прошедших с 1 января 1970 года UTC+0.</code></pre></li>
<li><h3>Установка компонентов даты</h3>
<pre><code class="language-js">let now = new Date();
// До set
    console.log(now) // Mon Jul 26 2021 15:45:24 GMT+0600 (Восточный Казахстан)

now.setFullYear(2010) // можно установить сразу (год, [месяц], [дата])
now.setMonth(8) // можно установить сразу (month, [date]) и запомните месяца идут от 0 до 11
now.setDate(19) // а вот даты месяца, как обычно с 1 до 31
now.setHours(18) // можно установить сразу (час, [минуту], [секунду], [миллисекунды])
now.setMinutes(30) // можно установить сразу (min, [sec], [ms])
now.setSeconds(25) // можно установить сразу (sec, [ms])
now.setMilliseconds(1000) // в 1с 1000мс

// После set
    console.log(now) // Mon Jul 19 2010 18:30:26 GMT+0600 (Восточный Казахстан)

setTime(milliseconds) (устанавливает дату в виде целого количества миллисекунд, прошедших с 01.01.1970 UTC) </code></pre></li>
</ul>
<h2>Разность между датами возвращает миллисекунды</h2>
<p>Если объект <b>Date</b> преобразовать в число, то получим таймстамп (количество мс прошедших с 01.01.1970 UTC) по аналогии с date.getTime().</p>
<pre><code class="language-js">let now = new Date();
console.log(+now); // 1627294248404 Количество мс прошедших с 01.01.1970 UTC</code></pre>
<p>Если нужно просто измерить время, объект Date нам не нужен. Существует особый метод <b>Date.now()</b>, возвращающий текущую метку времени. Хотя это тоже самое что и <b>new Date().getTime()</b></p>
<p>Сделаем Бенчмаркинг узнаем как быстро работает наш цикл.</p>
<pre><code class="language-js">let start = new Date(); // начинаем отсчёт времени

for (let i = 0; i < 100000; i++) { 
    let some=i ** 3 
} 

let end = new Date(); // заканчиваем отсчёт времени 
console.log(`Цикл отработал за ${end - start} миллисекунд`); // Цикл отработал за 8 миллисекунд</code></pre>

<h2>Осталось до конца акции</h2>
<p>Наверное вы часто видели на сайтах таймеры обратного отсчета, что то типа отсчет до конца Акции или какого нибудь События. Давайте сделаем свой <b>Таймер обратного отсчета</b>. Наш таймер будет считать дни до нового года .</p>

<pre><code class="language-js">// Текущий год + 1
let newYear = new Date().getFullYear() + 1;</code></pre>

<p>Для начала мы должны получить разницу между началом нового года и текущей даты </p>
<pre><code class="language-js">// Date.parse("date") - принимает дату в виде строки и возвращает мс от 1970г до "date" указанная в параметрах.
// Date.now() - возвращает мс от 1970г до текущего времени
    const t = Date.parse(`01 Jan ${newYear} 00:00:00`) - Date.now();</code></pre>

    <p>Далее у нас Математика. Сколько мс в одном дне(24ч) = 1000 * 60 * 60 * 24. Теперь чтобы получить количество дней нам надо полученные мс разделить на (1000 * 60 * 60 * 24) </p>
<pre><code class="language-js">let days = Math.floor(t / (1000 * 60 * 60 * 24)); 
    // Да и не забываем округлять до целого числа в меньшую сторону Math.floor()</code></pre>
    
    <p>Далее еще сложней, у нас пошли часы. Дней мы можем получить в любом количестве, а вот часы не должны превышать 23, и тут мы обращаемся к <b>ЛОГИЧЕСКИМ ОПЕРАТОРАМ</b>, а именно Взятие остатка <b>%</b>. Например у нас осталось 58 часов, мы получим 2 дня и 10 часов ( 50 % 24 == 10 (хвостик) )</p> 
<pre><code class="language-js">let hours = Math.floor( (t / (1000 * 60 * 60)) % 24) </code></pre>

<p>Далее минуты и секунды, и тут так же только хвост берем от %60</p>
<pre><code class="language-js">let minutes = Math.floor((t / (1000 * 60)) % 60);
let seconds = Math.floor((t / 1000) % 60);</code></pre>

<P>Теперь давайте все полученные данные для таймера будем получать как объект</P>
<pre><code class="language-js">let newYear = new Date().getFullYear() + 1;

function getTimeRemaining(endTime) {
    const t = Date.parse(endTime) - Date.now();

    let days = Math.floor(t / (1000 * 60 * 60 * 24));
    let hours = Math.floor((t / (1000 * 60 * 60)) % 24);
    let minutes = Math.floor((t / (1000 * 60)) % 60);
    let seconds = Math.floor((t / 1000) % 60);

    return {
        'total': t,
        'days': days,
        'hours': hours,
        'minutes': minutes,
        'seconds': seconds,
    }
}</code></pre>
<p>Теперь давайте установим наш таймер. Сперва найдем каждый селектор, а дальше создадим функцию обновления данных таймера. После создадим интервал для обновления таймера каждую секунду. И в завершении сделаем остановку таймера при наступлении newYear</p>
<pre><code class="language-js">// Обертка нашего таймера передается параметром <b>selector</b>, а наш newYear в <b>endTime</b>
function setClock(selector, endTime) {
    const timer = document.querySelector(selector),
        days = timer.querySelector("#days"),
        hours = timer.querySelector("#hours"),
        minutes = timer.querySelector("#minutes"),
        seconds = timer.querySelector("#seconds");

    // интервал который будет перезаписывать данные таймера каждую секунду
    const timeInterval = setInterval(updateClock, 1000)

    function updateClock() {
        // Наша функция возвращает в переменную t объект
        const t = getTimeRemaining(endTime);

        days.innerHTML = t.days;
        hours.innerHTML = t.hours;
        minutes.innerHTML = t.minutes;
        seconds.innerHTML = t.seconds;

        // Если мс до newYear <= 0, то отключаем наш интервал 
        if (t.total <=0) { 
            clearInterval(updateClock);
        }
    }  
}</code></pre>
<p>Добавляем 0 к часам, минутам, секундам если они меньше 10, то есть 09 ч 08 м 03 с </p>
<pre><code class="language-js">function setZero(num) {
    if (num < 10) { 
        return `0${num}`; 
    } else { 
        return num 
    } 
}</code></pre>
<p>Итоговый код таймера по ссылке: <span class="code_newyear">code</span> </p> 

<div class="promotion">


        <div class="promotion__timer">
            <div class="title">До нового года осталось:</div>
            <div class="timer">
                <div class="timer__block">
                    <span id="days">12</span>
                    дней
                </div>
                <div class="timer__block">
                    <span id="hours">20</span>
                    часов
                </div>
                <div class="timer__block">
                    <span id="minutes">56</span>
                    минут
                </div>
                <div class="timer__block">
                    <span id="seconds">20</span>
                    секунд
                </div>
            </div>
        </div>
    
</div>
                </div>
                <h1>Размеры и координаты элементов</h1>
                <div class="child scrolling hide">
                    <div class="img_block"><img src="img/metric.webp" class="img"></div>
                    <p> <b>offsetLeft/offsetTop</b> - это css свойства left и top относительно верхнего левого угла
                        offsetParent(родитель), который имеет <span style="background-color: #f5d9d9;">position: absolute, relative,
                            fixed или sticky</span> ,</p>
                    <p><b>offsetWidth/offsetHeight</b> - Они содержат «внешнюю» ширину/высоту элемента, то есть его полный размер,
                        включая рамки.</p>
                    <p> Получить ширину и высоту элемента в px можно с помощью свойств <b>clientWidth / clientHeight</b>. Иногда ширина
                        может быть меньше на ~15px из за полосы прокрутки, если она имеется у самого элемента</p>
                    <pre><code class="language-js">/*CSS*/
                .element {
                    width: 400px;
                    height: 500px;
                    padding: 10px;
                    border: 5px solid black;
                }
                /*JS*/
                element.clientWidth // 420
                element.clientHeight // 520
                // (полоса прокрутки отнимает 15px)
                element.clientWidth // 405 
                
                element.offsetWidth // 430 
                element.offsetHeight // 530</code></pre>
                    <h2>CSS свойство box-sizing</h2>
                    <p>В зависимости от значения CSS свойства box-sizing мы будем получать разные значения <b>clientWidth /
                            clientHeight</b>. у box-sizing есть два значения content-box и border-box. </p>
                    <p>При помощи box-sizing: border-box мы можем сказать браузеру, что ширина, которую мы ставим, относится к элементу
                        полностью, включая border и padding. Так что при <b>box-sizing: border-box</b> offsetWidth == width(css), а
                        clientWidth == (width - border - (ширина скролла, при наличии))</p>
                    <div class="img_block"><img src="img/border-box.jpg" class="img"></div>
                    <p></p>
                
                
                    <h2>Получим координаты элемента</h2>
                    <p class="content-text">В Java-Script существуют множество свойств, которые позволяют считывать информацию об
                        элементе: координаты, ширину, высоту и многое другое. В этой статье разбираю координаты. Координаты можно
                        использовать чтобы передвигать элементы, определять положение элемента относительно окна видимости клиента
                        (window) и другое. </p>
                    <p class="content-text">Метод <b>element.getBoundingClientRect()</b> возвращает размер элемента и его позицию
                        относительно viewport (часть страницы, показанная на экране, и которую мы видим). Возвращает данный метод в виде
                        объекта встроенного класса <b>DOMRect</b> .</p>
                    <pre><code class="language-js">const coords = elem.getBoundingClientRect();
                coords.widt // Ширина элемента 
                coords.height // высота элемента (могут быть отрицательными).
                coords.left // X-координата левой границы элемента
                coords.right // X-координата правой границы элемента
                coords.top // Y - координата верхней границы элемента,
                coords.bottom // Y - координата нижней границы элемента,
                coords.x // X-координаты начала элемента относительно окна,
                coords.y // Y-координаты начала элемента относительно окна,</code></pre>
                    <p class="content-text">Создал илюстрацию которая при наведении покажет координаты элемента. Зеленые относительно
                        окна, синие относительно страницы</p>
                
                    <div class="coords-wrapper">
                        <div class="coords-block">
                            <div class="coords-block_head">
                                <div class="coords-block_circle"></div>
                                <div class="coords-block_circle"></div>
                                <div class="coords-block_circle"></div>
                
                            </div>
                
                        </div>
                    </div>
                
                    <p class="content-text">Для начала находим элемент с помошью метода <b>querySelector()</b>. Далее получаем его
                        координаты.</p>
                    <pre><code class="language-js">const block = document.querySelector(".coords-block_head");
                const coordsBlock = block.getBoundingClientRect();
                    // относительно окна
                    coordsBlock.top // Верхний край элемента 
                    coordsBlock.left // Левый карай элемента 
                    coordsBlock.bottom // Нижний край элемента
                    coordsBlock.right // Правый край элемента 
                    // относительно страницы
                    coordsBlock.top + window.pageYOffset // Верхний край элемента
                    coordsBlock.bottom + window.pageYOffset // Нижний край элемента</code></pre>
                </div>
                <!-- /.date -->
            </div>
            
        </div>
    </section>


    <footer class="footer">
        <div class="container">
            <div class="abot-me">
                <h3>ERA AISAHANOV</h3>
                <p>Frontend Developer</p>
            </div>
            <div class="social-links">
                <a href="">
                    <svg class="icon">
                        <use xlink:href="img/icons.svg#vk-social-logotype"></use>
                    </svg>
                </a>
                <a href="">
                    <svg class="icon">
                        <use xlink:href="img/icons.svg#telegram"></use>
                    </svg>
                </a>
                <a href="">
                    <svg class="icon">
                        <use xlink:href="img/icons.svg#email"></use>
                    </svg>
                </a>
            </div>
        </div>
    </footer>
</body>

</html>